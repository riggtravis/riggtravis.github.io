<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Three Project Ideas | Travis Rigg&#39;s Blogging and Development Extravaganza | A 5 ring circus featuring discussions about writing code for programs</title>

  
  <meta name="author" content="Travis Rigg">
  

  
  <meta name="description" content="This is my development blog. It is basically a scratchpad.">
  

  
  
  <meta name="keywords" content="JavaScript,brainstorming,planning">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Three Project Ideas"/>

  <meta property="og:site_name" content="Travis Rigg&#39;s Blogging and Development Extravaganza"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Travis Rigg&#39;s Blogging and Development Extravaganza" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Travis Rigg&#39;s Blogging and Development Extravaganza</a>
    </h1>
    <p class="site-description">A 5 ring circus featuring discussions about writing code for programs</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Three Project Ideas</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/08/27/Three-Project-Ideas/" rel="bookmark">
        <time class="entry-date published" datetime="2016-08-28T02:03:24.000Z">
          2016-08-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>This is my first post on this blog, so I think I’d like to introduce it just a little bit before I get things going. This is my development blog. I post about things I am working on. Right now, I’m working on my senior capstone at Berea College. These are a few ideas that I’ve been thinking about to work on.</p>
<h1 id="Twitter-Bot-Detector"><a href="#Twitter-Bot-Detector" class="headerlink" title="Twitter Bot Detector"></a>Twitter Bot Detector</h1><p>Someone in our class pitched the idea of a Twitter Bot as a project. I, being a contrarian, immediately thought to myself that I should build a Twitter Bot Detector.</p>
<p>After looking into the viability of this project, I found that the University of Texas had already done this, so I looked at their work. There are several parts of detecting a twitter bot, all related to different aspects of a bot’s behavior.</p>
<p>The first thing to look at is how much content is the bot creating, and how much is it regurgitating via retweets. An actual human person will on occasion have something to say about something. It might be how their day was, it might be what they had for breakfast, it might be an excited tweet about the future times. Whatever it is, a human person will do this along side retweeting things that they found nifty.</p>
<p>The next tell tale sign of a twitter bot is the times of activity. Actual human people have things they have to do through out their day. They need sleep, they need food, they have to interact with physical people in the physical world, they need to rotate their fluids. Twitter bots don’t have to do any of these things. When looking at a human person’s twitter feed, it will have sporadic activity; it will have periods of rapid tweeting and retweeting followed by large blocks of doing other things. Twitter bots deviate from this behavior. They can have rather constant streams of activity.</p>
<p>Of course, modern twitter bots are sophisticated enough to pass both of these tests. The next analyses are a little more sophisticated. They require information and language processing that might be a little complex for a single semester of work. I’m still going to describe them because I might decide that they are actually simple enough, or someone else in our class might say to themselves, “Hey. Travis might not be very good at these things, but I’ve done them before, I feel really comfortable with them.”</p>
<p>The next thing that Twitter Bots don’t have in common with human people is sensible social networks. Human people have friends who know their other friends You can reasonably expect a human user of twitter to have several followers who not only follow the account in question, but also follow the several other accounts that follow them as well as the account in question. This however does need to take into consideration extremely popular twitter accounts as well as verified accounts (which are generally popular).</p>
<p>Even so, twitter bot builders have gotten sophisticated enough to subvert this test method as well. They’ll set up several bot accounts that all follow each other creating a social network of bots. I’m sure there are still ways to detect this form of activity, but what I’m not sure about is how to do this. I would probably put more thought into the next detection method before coming back around to this.</p>
<p>Human people usually use language in a certain way. One example would be that human people don’t say “human people.” I’ve been doing that through this portion of the blog post to get ready for this part of it. A bot detector needs to do some language processing to see how human a questionable account seems to be in its tweets. Ideally this mechanism would be quite robust, but a language processor could make an entire project in itself. For the purposes of this course, the bot detector’s ability to process language should be very basic.</p>
<p>Each on their own, these methods can create quite a few false positives, or miss advanced bots that successfully circumvent their methods. One needs to gather results from each method and process them in order to come to an actual conclusion. The first method I thought of to compile this data was a neural network, but there are probably other ways as well.</p>
<p>Conveniently, these are five different parts of creating a twitter bot detector, and they are all rather modular. I think the completion of each component in order make for excellent milestones for our senior projects course. I don’t think spacing the components evenly is a wise plan though. The content vs regurgitation component should take less time than the others, though it is also the first component and needs to take learning how twitter handles data into consideration. Content vs regurgitation should take two weeks.</p>
<p>The activity monitor is also pretty simple, and should take about the same amount of time as the content vs regurgitation component. However, the programmer will already be familiar with how Twitter handles data by this time. I think this should only take a week.</p>
<p>This leaves 12 weeks to handle the big problems. I would allocate four weeks to social network analysis, three to handle language processing, and two to set up a neural network. I’ve given language processing a little less time because I don’t think I can possibly come up with something adequate even given the whole semester. I do however I think I can come up with something super basic if given three weeks given some of the excellent resources available to us here at Berea College in the form of our professors. Two weeks might seem like a long time to set up a neural network, but in my experience, the tools for this are buggy and poorly documented.</p>
<p>This leaves three weeks for testing and fixing. That is less time than I would like for a project of this complexity, especially given that attempts at budgeting time for it might be way off scale for how much any component that turns out to be more complex than initially believed. That being said, after writing out the necessary steps, this project seems much more realistic than it had when it was bouncing around in my head.</p>
<p>This project also gives me an opportunity to grow because it is so different from the things that I have been working on. The problem for me is that I don’t think it gives me any utility growth, that being growth I can use. It would be a fun project centered around things I don’t know much about, but I don’t see a future path that would be strengthened by this project.</p>
<p>I still feel like all of this was more than I could handle over a single semester. I think I would be more interested in it if no one had done anything in the field, or enough people had done work on the problem that I could make a small tweak on a proven concept to make something interesting.</p>
<p>Taking a proven concept and putting a small tweak on it to create something interesting brings me into my next topic…</p>
<h1 id="Email-Client"><a href="#Email-Client" class="headerlink" title="Email Client"></a>Email Client</h1><p>Using Node and Electron, JavaScript can be used for nearly anything. I would like to play with creating an email client using electron.</p>
<p>Sending email using HTML formatted text can be really annoying when there’s a WYSIWYG editing pane that refuses to rest control when the user asks for it (looking at you, Evolution). I would like to create one that has an editing pane on the left that displays in plain text, and a preview window on the right that displays what the email will look like to its recipient.</p>
<p>This email client would not be comprehensive. It would only support the most widely used protocols such as IMAP. Protocols like Exchange would be too big to worry about in a single semester. I would rather focus on creating a well polished, easy to use, basic email client than a feature complete email client that doesn’t look nice. There’s Mutt for that.</p>
<p>I think it’s worth considering when thinking about both the user interface and milestones for the project what the views in an email client are. Usually you have a pane for your folders, a pane that displays your emails in a list format, a pane that displays the content of a single email, a pane for composing your email, and a set up pane. That is five panes total.</p>
<p>While it might seem like the best plan is to divide the term into milestones for each of these components, I think a better plan would be to cycle through these components rapidly, and improve them on each cycle. What I mean by this is that instead of blocking out 3 weeks straight to work on the composition pane, I would maybe spend each of my sessions in those three weeks working on a single view, creating an iteration of the whole every three weeks.</p>
<p>The work schedule I have set up for myself includes five hours on Thursday and five hours on Friday each week to work on my project. I would do something like Spending the Thursday of the start of each three week cycle designing how I want things to work, and then the Friday working on one component. The next week I would spend Thursday one of the remaining four components, and Friday working on one of the remaining three. In the third and final week of each cycle I would work on the two components I hadn’t worked on yet.</p>
<p>This gives a sort of release cycle milestone set up that I think would work a lot like working on a novella or paper. First you create a rough draft, one in this case that might not even function completely properly. The first editing session you spend figuring out what you like and don’t like about your rough draft, making changes to the structure of your rough draft, and fixing major bugs with the system, producing a second draft.</p>
<p>The reason I refer to the releases as drafts is that you might come up with an interface concept that in practice isn’t as good as you thought it was, so then you would have to spend quite a bit of time making major changes to the way things were. The other reason is that much like in writing a paper, there are going to be errors in the code of the program. This is especially true because Electron is a technology that I am not familiar with working on from scratch. Any programming that I have done in the environment has been working with a preexisting project.</p>
<p>It’s sort of strange to think that one of the ideas I’m considering is centered around a user interface idea that I have. User interfaces always presented me problems when they were introduced in whatever programming language tutorial I was working through. I am hopeful that my experience using MinCSS to style pages will provide some help, given that Electron apps are essentially web pages.</p>
<p>Just as interesting twists on ideas drew me directly into this idea, web pages draws me into the next one…</p>
<h1 id="Static-Web-Page-Generator"><a href="#Static-Web-Page-Generator" class="headerlink" title="Static Web Page Generator"></a>Static Web Page Generator</h1><p>A Static Web Page Framework takes input files and uses them to build a website. I want to build one that doesn’t require compilation or installation.</p>
<p>This is the idea I have put the most thought into, which is why I have presented it last. I wanted to give the other ideas I have a chance in the sun in case someone else had interest in them. I don’t want my excited energy to dissuade anyone else from thinking about my other ideas. I think they’re both fun ideas that could be really interesting to play with, but this is the idea that I’m the most interested in doing.</p>
<p>Over the summer, a friend of mine asked for help building a website for her business. That website is still in progress, but over the course of getting it to it’s current status (bug fixes), I learned a lot about creating a web page by dynamically loading information into a view using JSON files. I still think I can do better.</p>
<p>I want to create a general purpose static web page framework along these same principles. All of the processing of data will be handled by the web browser. This makes my project significantly different from something like Hexo. With most Static Website Generators, you write files, and then run some form of compilation. HTML files are output, and those are used for the website.</p>
<p>My project will require no compilation. A single HTML file will use JavaScript to inject information into HTML elements. Before I have done this using JSON files that contain the information that is to be injected. I would like to use something more human readable like markdown. The specific tools that I would use to make this happen would be Mustache.js, jQuery, and Markdown.js.</p>
<p>Milestones would be structured around how I set up my initial project. What I am planning to do is to create a single JSON object that contains all the information necessary to create a website. Each step of building my project would entail removing a component from the object and moving it into another file structure.</p>
<p><img src="http://i.imgur.com/TRwYl69.jpg" alt="I may or may not have left the pen in the shot because I think it looks nifty"></p>
<p>The first milestone will be setting up the website to work on this base object. Functionality can be drawn out of this object into other files for future milestones. This first milestone is rather large because it includes such things as writing the HTML code that will be used to display the content and integrating Markdown.js and Mustache.js to turn the content into HTML. I expect this to take two weeks.</p>
<p>The second milestone will be a simple one. I want to draw the site information away from the basic starter object into its own file. This will include things that are the same on every single page that the user visits like the title of the website, the favicon, and the contact information of the site owner. This milestone won’t take very long because it is so simple. I expect it to take a week. This might seem like a lot of time to dedicate to this task, but I expect there to be ideas I have to make this feature even better and more human readable while I work on it.</p>
<p>The third milestone will be to draw content out of the main object and separate it into markdown files. The content of files on a server can be accessed using AJAX as long as the file name is known. This is why the filenames will still be in the main object. In fact, at this point in the project, the filenames will be the only things left in the object. I already have experience doing this, but it still takes quite a bit of code to do. I think it will take me about two weeks.</p>
<p>The fourth milestone will be the hardest one. I want to get rid of the object entirely. I would like to use a web server’s directory listing to gather the names of all of the markdown files so that the JavaScript can pull content from these files without being told explicitly what their names are. I think this should take four weeks.</p>
<p>The final milestone will be to modify the project so that when someone searches the web the content of the site can be queried by the search engine of their choice. I’m not very sure how hard this will be, so I would like to dedicate as much time to it as I did for the web server directory listing milestone. All in all, this leaves three weeks for testing and fixing, as well as room for if one of these tasks presents unforeseen problems and takes more time to work on than was originally budgeted. That’s pretty accurate to how I want my senior project to be structured, so I feel really comfortable with this idea being the one I go forward with. I might be favoring it unfairly, but I just think it fits the structure of this course better than my other ideas, and is the one I have the most familiarity with.</p>
<p>A human readable compilation free static website framework could be a really great thing for people hosting websites on servers and don’t know much about creating web pages. It would provide a path for minimal set up, though it would decrease the responsiveness and performance of the website. This is a sacrifice I am willing to make for the sake of a fun project that does something interesting.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/JavaScript/">JavaScript</a><a href="/tags/brainstorming/">brainstorming</a><a href="/tags/planning/">planning</a>
    </span>
    

    </div>

    
  </div>
</article>

  



    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2016 Travis Rigg
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>